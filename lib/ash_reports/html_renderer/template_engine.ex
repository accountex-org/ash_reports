defmodule AshReports.HtmlRenderer.TemplateEngine do
  @moduledoc """
  Phase 3.2.1 HTML Template System - EEx-based template engine with layout support.

  The TemplateEngine provides sophisticated HTML template processing using Elixir's
  EEx (Embedded Elixir) template system, enabling dynamic HTML generation with
  full context awareness and layout management.

  ## Key Features

  - **EEx Template Processing**: Native Elixir template compilation and rendering
  - **Layout Management**: Master page templates with content blocks
  - **Context Integration**: Full RenderContext variable and data access
  - **Template Caching**: Pre-compiled templates for optimal performance
  - **Partial Support**: Reusable template components and includes
  - **Semantic HTML**: Standards-compliant HTML5 output

  ## Template Types

  ### Master Layout Template

  Defines the overall HTML document structure:

  ```html
  <!DOCTYPE html>
  <html lang="<%= @lang %>">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= @report_title %></title>
    <%= if @embed_css do %>
      <style><%= @css_content %></style>
    <% else %>
      <link rel="stylesheet" href="<%= @css_url %>">
    <% end %>
  </head>
  <body class="ash-reports-body">
    <%= @content %>
  </body>
  </html>
  ```

  ### Report Template

  Defines the report structure within the layout:

  ```html
  <div class="ash-report" data-report="<%= @report.name %>">
    <header class="ash-report-header">
      <%= render_header(@context) %>
    </header>

    <main class="ash-report-content">
      <%= for band <- @bands do %>
        <%= render_band(band, @context) %>
      <% end %>
    </main>

    <footer class="ash-report-footer">
      <%= render_footer(@context) %>
    </footer>
  </div>
  ```

  ### Band Template

  Defines individual band rendering:

  ```html
  <section class="ash-band ash-band-<%= @band.type %>"
           data-band="<%= @band.name %>">
    <%= for element <- @band.elements do %>
      <%= render_element(element, @context) %>
    <% end %>
  </section>
  ```

  ## Usage

      # Basic template rendering
      {:ok, html} = TemplateEngine.render_complete_html(context, css, elements)

      # Custom template
      {:ok, html} = TemplateEngine.render_template(:custom, context, assigns)

      # Template compilation
      {:ok, compiled} = TemplateEngine.compile_template("template.html.eex")

  """

  alias AshReports.RenderContext

  @type template_name :: atom() | String.t()
  @type template_assigns :: %{atom() => term()}
  @type compiled_template :: function()

  # Template cache for pre-compiled templates - will be created on first use

  @default_templates %{
    master: """
    <!DOCTYPE html>
    <html lang="<%= @lang %>">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title><%= @report_title %></title>
      <style>
        <%= @css_content %>
      </style>
    </head>
    <body class="ash-reports-body">
      <%= @content %>
    </body>
    </html>
    """,
    report: """
    <div class="ash-report">
      <header class="ash-report-header">
        <h1 class="ash-report-title"><%= @report_title %></h1>
      </header>
      
      <main class="ash-report-content">
        <%= @bands_content %>
      </main>
      
      <footer class="ash-report-footer">
        <p class="ash-report-footer-text">Generated by AshReports</p>
      </footer>
    </div>
    """,
    band: """
    <section class="ash-band ash-band-<%= @band_type %>" data-band="<%= @band_name %>">
      <%= @elements_content %>
    </section>
    """,
    element_wrapper: """
    <div class="ash-element ash-element-<%= @element_type %>" data-element="<%= @element_name %>">
      <%= @element_content %>
    </div>
    """
  }

  @doc """
  Renders the complete HTML document with layout, CSS, and content.

  ## Examples

      {:ok, html} = TemplateEngine.render_complete_html(context, css_content, html_elements)

  """
  @spec render_complete_html(RenderContext.t(), String.t(), [map()]) ::
          {:ok, String.t()} | {:error, term()}
  def render_complete_html(%RenderContext{} = context, css_content, html_elements) do
    with {:ok, bands_content} <- render_all_bands(context, html_elements),
         {:ok, report_content} <- render_report_content(context, bands_content),
         {:ok, complete_html} <- render_master_layout(context, css_content, report_content) do
      {:ok, complete_html}
    else
      {:error, _reason} = error -> error
    end
  end

  @doc """
  Renders a specific template with the given assigns.

  ## Examples

      assigns = %{title: "My Report", content: "<p>Hello World</p>"}
      {:ok, html} = TemplateEngine.render_template(:master, assigns)

  """
  @spec render_template(template_name(), template_assigns()) ::
          {:ok, String.t()} | {:error, term()}
  def render_template(template_name, assigns) do
    case get_compiled_template(template_name) do
      {:ok, compiled_template} ->
        html = compiled_template.(assigns)
        {:ok, html}

      {:error, _reason} = error ->
        error
    end
  rescue
    error ->
      {:error, {:template_render_error, error}}
  end

  @doc """
  Compiles a template string into an executable function.

  ## Examples

      template_string = "<h1><%= @title %></h1>"
      {:ok, compiled} = TemplateEngine.compile_template_string(template_string)

  """
  @spec compile_template_string(String.t()) :: {:ok, compiled_template()} | {:error, term()}
  def compile_template_string(template_string) when is_binary(template_string) do
    compiled = EEx.compile_string(template_string, trim: true)
    {:ok, compiled}
  rescue
    error ->
      {:error, {:compilation_error, error}}
  end

  @doc """
  Validates that all required templates are available and compilable.

  ## Examples

      case TemplateEngine.validate_templates() do
        :ok -> proceed_with_rendering()
        {:error, missing} -> handle_missing_templates(missing)
      end

  """
  @spec validate_templates() :: :ok | {:error, [atom()]}
  def validate_templates do
    required_templates = [:master, :report, :band, :element_wrapper]

    missing_templates =
      Enum.reject(required_templates, fn template_name ->
        case get_compiled_template(template_name) do
          {:ok, _compiled} -> true
          {:error, _reason} -> false
        end
      end)

    if missing_templates == [] do
      :ok
    else
      {:error, missing_templates}
    end
  end

  @doc """
  Clears the template cache and cleans up temporary resources.

  ## Examples

      TemplateEngine.cleanup_temporary_templates()

  """
  @spec cleanup_temporary_templates() :: :ok
  def cleanup_temporary_templates do
    if :ets.whereis(:template_cache) != :undefined do
      :ets.delete_all_objects(:template_cache)
    end

    :ok
  end

  @doc """
  Registers a custom template for use in rendering.

  ## Examples

      template_content = "<h1><%= @title %></h1><p><%= @content %></p>"
      TemplateEngine.register_template(:custom, template_content)

  """
  @spec register_template(template_name(), String.t()) :: :ok | {:error, term()}
  def register_template(template_name, template_content) when is_binary(template_content) do
    case compile_template_string(template_content) do
      {:ok, compiled} ->
        ensure_cache_table()
        :ets.insert(:template_cache, {template_name, compiled})
        :ok

      {:error, _reason} = error ->
        error
    end
  end

  @doc """
  Gets template information and statistics.

  ## Examples

      info = TemplateEngine.get_template_info()

  """
  @spec get_template_info() :: map()
  def get_template_info do
    ensure_cache_table()

    cache_size = :ets.info(:template_cache, :size)
    default_templates_count = map_size(@default_templates)

    %{
      cache_size: cache_size,
      default_templates_count: default_templates_count,
      available_templates: get_available_templates(),
      cache_memory: :ets.info(:template_cache, :memory)
    }
  end

  # Private implementation functions

  defp render_all_bands(%RenderContext{} = context, html_elements) do
    bands_content =
      context.report.bands
      |> Enum.map(fn band ->
        band_elements = filter_elements_for_band(html_elements, band.name)
        render_single_band(band, band_elements, context)
      end)
      |> Enum.join("\n")

    {:ok, bands_content}
  end

  defp render_single_band(band, band_elements, %RenderContext{} = context) do
    elements_content = Enum.join(band_elements, "\n")

    assigns = %{
      band_name: band.name,
      band_type: Map.get(band, :type, :detail),
      elements_content: elements_content,
      context: context
    }

    case render_template(:band, assigns) do
      {:ok, html} -> html
      {:error, _reason} -> ""
    end
  end

  defp filter_elements_for_band(html_elements, band_name) do
    Enum.filter(html_elements, fn element ->
      element[:band_name] == band_name
    end)
    |> Enum.map(& &1[:html_content])
  end

  defp render_report_content(%RenderContext{} = context, bands_content) do
    report_title =
      context.report
      |> Map.get(:title, context.report.name |> to_string() |> String.capitalize())

    assigns = %{
      report_title: report_title,
      bands_content: bands_content || ""
    }

    render_template(:report, assigns)
  end

  defp render_master_layout(%RenderContext{} = context, css_content, report_content) do
    report_title =
      context.report
      |> Map.get(:title, context.report.name |> to_string() |> String.capitalize())

    assigns = %{
      lang: get_config_value(context, :lang, "en"),
      report_title: report_title,
      css_content: css_content || "",
      content: report_content || ""
    }

    render_template(:master, assigns)
  end

  defp get_config_value(%RenderContext{} = context, key, default) do
    context.config
    |> Map.get(:html, %{})
    |> Map.get(key, default)
  end

  defp ensure_cache_table do
    if :ets.whereis(:template_cache) == :undefined do
      :ets.new(:template_cache, [:set, :public, :named_table])
    end

    :ok
  end

  defp get_compiled_template(template_name) do
    ensure_cache_table()

    case :ets.lookup(:template_cache, template_name) do
      [{^template_name, compiled}] ->
        {:ok, compiled}

      [] ->
        compile_from_default_templates(template_name)
    end
  end

  defp compile_from_default_templates(template_name) do
    case Map.get(@default_templates, template_name) do
      nil ->
        {:error, {:template_not_found, template_name}}

      template_content ->
        case compile_and_cache_template(template_name, template_content) do
          {:ok, compiled} -> {:ok, compiled}
          {:error, _reason} = error -> error
        end
    end
  end

  defp compile_and_cache_template(template_name, template_content) do
    case compile_template_string(template_content) do
      {:ok, compiled} ->
        ensure_cache_table()
        :ets.insert(:template_cache, {template_name, compiled})
        {:ok, compiled}

      {:error, _reason} = error ->
        error
    end
  end

  defp get_available_templates do
    ensure_cache_table()

    cached_templates =
      :ets.tab2list(:template_cache)
      |> Enum.map(fn {name, _compiled} -> name end)

    default_template_names = Map.keys(@default_templates)

    (cached_templates ++ default_template_names)
    |> Enum.uniq()
  end
end
