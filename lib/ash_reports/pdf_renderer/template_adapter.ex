defmodule AshReports.PdfRenderer.TemplateAdapter do
  @moduledoc """
  Phase 3.4.4 Template Adapter - HTML template optimization for PDF output.

  The TemplateAdapter takes HTML content generated by the HtmlRenderer and optimizes
  it specifically for PDF generation, including print CSS injection, layout
  adjustments, page break optimization, and ChromicPDF compatibility enhancements.

  ## Key Features

  - **Print CSS Injection**: Seamless integration of print-optimized CSS
  - **Layout Optimization**: Adjusts HTML structure for optimal PDF rendering
  - **Page Break Enhancement**: Intelligent page break placement in HTML structure
  - **Typography Refinement**: Font and text optimizations for print quality
  - **ChromicPDF Compatibility**: Ensures HTML is fully compatible with ChromicPDF

  ## Template Optimization Process

  1. **Parse HTML**: Analyze existing HTML structure and content
  2. **Inject Print CSS**: Add print-optimized stylesheets and media queries
  3. **Optimize Layout**: Adjust HTML structure for PDF page flow
  4. **Enhance Typography**: Refine fonts, spacing, and text rendering
  5. **Add Page Breaks**: Insert intelligent page break markers
  6. **Finalize HTML**: Produce ChromicPDF-ready HTML

  ## Usage

      html_content = "<html>...</html>"
      print_css = "/* print styles */"
      page_layout = %{headers: ..., footers: ...}
      
      {:ok, pdf_html} = TemplateAdapter.optimize_for_pdf(
        html_content,
        print_css,
        page_layout,
        context
      )

  """

  alias AshReports.RenderContext

  @doc """
  Optimizes HTML content for PDF generation with comprehensive enhancements.

  Takes base HTML content and applies print-specific optimizations including
  CSS injection, layout adjustments, and ChromicPDF compatibility enhancements.

  ## Examples

      base_html = "<html><body>...</body></html>"
      print_css = generate_print_css(context)
      page_layout = setup_page_layout(context)
      
      {:ok, optimized_html} = TemplateAdapter.optimize_for_pdf(
        base_html,
        print_css,
        page_layout,
        context
      )

  """
  @spec optimize_for_pdf(String.t(), String.t(), map(), RenderContext.t()) ::
          {:ok, String.t()} | {:error, term()}
  def optimize_for_pdf(html_content, print_css, page_layout, %RenderContext{} = context) do
    with {:ok, parsed_html} <- parse_html_content(html_content),
         {:ok, enhanced_head} <- enhance_html_head(parsed_html, print_css, page_layout, context),
         {:ok, optimized_body} <- optimize_html_body(parsed_html, page_layout, context),
         {:ok, final_html} <- assemble_optimized_html(enhanced_head, optimized_body, context) do
      {:ok, final_html}
    else
      {:error, _reason} = error -> error
    end
  end

  @doc """
  Injects print CSS into HTML head section with proper media queries.

  Adds print-optimized CSS to the HTML head, ensuring proper media query
  setup and compatibility with ChromicPDF rendering.
  """
  @spec inject_print_css(String.t(), String.t()) :: {:ok, String.t()} | {:error, term()}
  def inject_print_css(html_content, print_css) do
    case parse_html_content(html_content) do
      {:ok, parsed_html} ->
        enhanced_html = add_print_css_to_head(parsed_html, print_css)
        {:ok, render_html_document(enhanced_html)}

      {:error, _reason} = error ->
        error
    end
  end

  @doc """
  Optimizes HTML structure for page breaks and PDF flow.

  Analyzes HTML content and inserts page break markers, adjusts layout
  for proper page flow, and ensures optimal PDF rendering structure.
  """
  @spec optimize_page_breaks(String.t(), map()) :: {:ok, String.t()} | {:error, term()}
  def optimize_page_breaks(html_content, page_layout) do
    with {:ok, parsed_html} <- parse_html_content(html_content),
         {:ok, break_optimized} <- insert_page_break_markers(parsed_html, page_layout),
         {:ok, layout_optimized} <- adjust_page_flow(break_optimized, page_layout) do
      {:ok, render_html_document(layout_optimized)}
    else
      {:error, _reason} = error -> error
    end
  end

  @doc """
  Enhances HTML typography for professional PDF output.

  Applies font optimizations, line height adjustments, and text rendering
  enhancements specifically designed for high-quality PDF generation.
  """
  @spec enhance_typography(String.t(), RenderContext.t()) :: {:ok, String.t()} | {:error, term()}
  def enhance_typography(html_content, %RenderContext{} = context) do
    with {:ok, parsed_html} <- parse_html_content(html_content),
         {:ok, font_optimized} <- optimize_font_declarations(parsed_html, context),
         {:ok, text_optimized} <- enhance_text_rendering(font_optimized, context) do
      {:ok, render_html_document(text_optimized)}
    else
      {:error, _reason} = error -> error
    end
  end

  @doc """
  Cleans up temporary template resources and files.

  Removes any temporary template files created during the optimization process.
  """
  @spec cleanup_temporary_templates() :: :ok
  def cleanup_temporary_templates do
    cleanup_temp_template_files()
    cleanup_template_cache()
    :ok
  end

  # Private implementation functions

  defp parse_html_content(html_content) do
    # Simple HTML parsing - in production, you might want to use a proper HTML parser
    try do
      parsed = %{
        doctype: extract_doctype(html_content),
        html_tag: extract_html_tag(html_content),
        head: extract_head_section(html_content),
        body: extract_body_section(html_content),
        raw_content: html_content
      }

      {:ok, parsed}
    rescue
      error -> {:error, {:html_parse_error, error}}
    end
  end

  defp enhance_html_head(parsed_html, print_css, page_layout, %RenderContext{} = context) do
    with {:ok, base_head} <- build_base_head_section(parsed_html, context),
         {:ok, css_enhanced} <- add_print_css_to_head(base_head, print_css),
         {:ok, meta_enhanced} <- add_pdf_meta_tags(css_enhanced, context),
         {:ok, page_enhanced} <- add_page_layout_styles(meta_enhanced, page_layout) do
      {:ok, page_enhanced}
    else
      {:error, _reason} = error -> error
    end
  end

  defp optimize_html_body(parsed_html, page_layout, %RenderContext{} = context) do
    with {:ok, structure_optimized} <- optimize_body_structure(parsed_html, context),
         {:ok, break_optimized} <- insert_page_break_markers(structure_optimized, page_layout),
         {:ok, element_optimized} <- optimize_pdf_elements(break_optimized, context),
         {:ok, final_body} <- finalize_body_optimization(element_optimized, context) do
      {:ok, final_body}
    else
      {:error, _reason} = error -> error
    end
  end

  defp assemble_optimized_html(enhanced_head, optimized_body, %RenderContext{} = context) do
    html_document = build_complete_html_document(enhanced_head, optimized_body, context)
    {:ok, html_document}
  end

  defp extract_doctype(html_content) do
    case Regex.run(~r/<!DOCTYPE[^>]*>/i, html_content) do
      [doctype] -> doctype
      nil -> "<!DOCTYPE html>"
    end
  end

  defp extract_html_tag(html_content) do
    case Regex.run(~r/<html[^>]*>/i, html_content) do
      [html_tag] -> html_tag
      nil -> "<html lang=\"en\">"
    end
  end

  defp extract_head_section(html_content) do
    case Regex.run(~r/<head[^>]*>(.*?)<\/head>/mis, html_content) do
      [_, head_content] -> head_content
      nil -> ""
    end
  end

  defp extract_body_section(html_content) do
    case Regex.run(~r/<body[^>]*>(.*?)<\/body>/mis, html_content) do
      [_, body_content] -> body_content
      # Fallback if no body tags found
      nil -> html_content
    end
  end

  defp build_base_head_section(parsed_html, %RenderContext{} = context) do
    base_head = """
    <meta charset="UTF-8">
    <meta name="generator" content="AshReports Phase 3.4 PDF Renderer">
    <meta name="pdf-optimized" content="true">
    <title>#{get_document_title(context)}</title>
    #{parsed_html.head}
    """

    {:ok, base_head}
  end

  defp add_print_css_to_head(head_content, print_css) when is_binary(head_content) do
    enhanced_head = """
    #{head_content}
    <style type="text/css" media="print">
    #{print_css}
    </style>
    """

    {:ok, enhanced_head}
  end

  defp add_print_css_to_head(parsed_html, print_css) when is_map(parsed_html) do
    add_print_css_to_head(parsed_html.head, print_css)
  end

  defp add_pdf_meta_tags(head_content, %RenderContext{} = context) do
    pdf_config = context.config[:pdf] || %{}

    pdf_meta_tags = """
    <meta name="pdf-page-size" content="#{pdf_config[:page_size] || "A4"}">
    <meta name="pdf-orientation" content="#{pdf_config[:orientation] || "portrait"}">
    <meta name="pdf-print-quality" content="#{pdf_config[:print_quality] || "high"}">
    <meta name="ash-reports-phase" content="3.4.0">
    """

    enhanced_head = head_content <> pdf_meta_tags
    {:ok, enhanced_head}
  end

  defp add_page_layout_styles(head_content, page_layout) do
    page_styles = generate_page_layout_css(page_layout)

    enhanced_head = """
    #{head_content}
    <style type="text/css" media="print">
    #{page_styles}
    </style>
    """

    {:ok, enhanced_head}
  end

  defp generate_page_layout_css(page_layout) do
    """
    /* Page Layout Styles from TemplateAdapter */
    @page {
      size: #{get_css_page_size(page_layout)};
      margin: #{get_css_margins(page_layout)};
    }

    #{generate_header_css(page_layout)}
    #{generate_footer_css(page_layout)}
    #{generate_page_break_css(page_layout)}
    """
  end

  defp get_css_page_size(%{page_dimensions: dimensions}) do
    case dimensions do
      %{width: w, height: h, unit: :mm} -> "#{w}mm #{h}mm"
      _ -> "A4"
    end
  end

  defp get_css_page_size(_), do: "A4"

  defp get_css_margins(%{margins: margins}) do
    "#{margins.top}mm #{margins.right}mm #{margins.bottom}mm #{margins.left}mm"
  end

  defp get_css_margins(_), do: "20mm"

  defp generate_header_css(%{headers: %{enabled: true}} = page_layout) do
    """
    @page {
      @top-center {
        content: "#{page_layout.headers.content.center}";
        font-family: #{page_layout.headers.styling.font_family};
        font-size: #{page_layout.headers.styling.font_size};
      }
    }
    """
  end

  defp generate_header_css(_), do: ""

  defp generate_footer_css(%{footers: %{enabled: true}} = page_layout) do
    """
    @page {
      @bottom-center {
        content: "#{page_layout.footers.content.center}";
        font-family: #{page_layout.footers.styling.font_family};
        font-size: #{page_layout.footers.styling.font_size};
      }
    }
    """
  end

  defp generate_footer_css(_), do: ""

  defp generate_page_break_css(%{page_breaks: page_breaks}) do
    """
    /* Page Break Rules */
    #{Enum.map_join(page_breaks.avoid_elements || [], "\n", fn element -> "#{element} { page-break-inside: avoid; }" end)}

    #{Enum.map_join(page_breaks.break_before || [], "\n", fn element -> "#{element} { page-break-before: always; }" end)}

    #{Enum.map_join(page_breaks.break_after || [], "\n", fn element -> "#{element} { page-break-after: always; }" end)}
    """
  end

  defp generate_page_break_css(_), do: ""

  defp optimize_body_structure(parsed_html, %RenderContext{} = _context) do
    # Wrap body content in PDF-optimized container
    optimized_body = """
    <div class="ash-pdf-container">
      #{parsed_html.body}
    </div>
    """

    {:ok, %{parsed_html | body: optimized_body}}
  end

  defp insert_page_break_markers(parsed_html, page_layout) do
    body_content = parsed_html.body

    # Insert page break markers based on content analysis
    enhanced_body =
      body_content
      |> insert_section_breaks(page_layout)
      |> insert_table_breaks(page_layout)
      |> insert_logical_breaks(page_layout)

    {:ok, %{parsed_html | body: enhanced_body}}
  end

  defp insert_section_breaks(body_content, _page_layout) do
    # Insert page breaks before major sections
    body_content
    |> String.replace(
      ~r/<div class="ash-band"/,
      "<div class=\"ash-page-break-candidate\"></div><div class=\"ash-band\""
    )
  end

  defp insert_table_breaks(body_content, _page_layout) do
    # Ensure tables don't break across pages inappropriately
    body_content
    |> String.replace(
      ~r/<table/,
      "<div class=\"ash-table-container ash-page-break-avoid\"><table"
    )
    |> String.replace(~r/<\/table>/, "</table></div>")
  end

  defp insert_logical_breaks(body_content, _page_layout) do
    # Insert logical page breaks at content boundaries
    body_content
  end

  defp optimize_pdf_elements(parsed_html, %RenderContext{} = _context) do
    body_content = parsed_html.body

    # Optimize various elements for PDF rendering
    optimized_body =
      body_content
      |> optimize_images_for_pdf()
      |> optimize_tables_for_pdf()
      |> optimize_text_for_pdf()
      |> optimize_layout_for_pdf()

    {:ok, %{parsed_html | body: optimized_body}}
  end

  defp optimize_images_for_pdf(body_content) do
    # Ensure images are properly sized for PDF
    body_content
    |> String.replace(~r/<img([^>]*?)>/, "<img\\1 style=\"max-width: 100%; height: auto;\">")
  end

  defp optimize_tables_for_pdf(body_content) do
    # Add PDF-specific table optimizations
    body_content
    |> String.replace(~r/<table/, "<table class=\"ash-pdf-table\"")
  end

  defp optimize_text_for_pdf(body_content) do
    # Optimize text rendering for PDF
    body_content
  end

  defp optimize_layout_for_pdf(body_content) do
    # General layout optimizations for PDF
    body_content
  end

  defp finalize_body_optimization(parsed_html, %RenderContext{} = _context) do
    # Final optimizations and cleanup
    {:ok, parsed_html}
  end

  defp build_complete_html_document(enhanced_head, optimized_body, %RenderContext{} = _context) do
    """
    <!DOCTYPE html>
    <html lang="en">
    <head>
    #{enhanced_head}
    </head>
    <body class="ash-pdf-body">
    #{optimized_body.body}
    </body>
    </html>
    """
  end

  defp render_html_document(parsed_html) when is_map(parsed_html) do
    """
    #{parsed_html[:doctype] || "<!DOCTYPE html>"}
    #{parsed_html[:html_tag] || "<html lang=\"en\">"}
    <head>
    #{parsed_html.head}
    </head>
    <body>
    #{parsed_html.body}
    </body>
    </html>
    """
  end

  defp render_html_document(html_content) when is_binary(html_content) do
    html_content
  end

  defp adjust_page_flow(parsed_html, _page_layout) do
    # Adjust HTML structure for optimal page flow
    {:ok, parsed_html}
  end

  defp optimize_font_declarations(parsed_html, %RenderContext{} = _context) do
    # Optimize font declarations for PDF rendering
    {:ok, parsed_html}
  end

  defp enhance_text_rendering(parsed_html, %RenderContext{} = _context) do
    # Enhance text rendering properties
    {:ok, parsed_html}
  end

  defp get_document_title(%RenderContext{} = context) do
    context.report[:title] || "AshReports PDF Document"
  end

  defp cleanup_temp_template_files do
    # Clean up any temporary template files
    temp_pattern = Path.join(System.tmp_dir(), "ash_reports_template_*.html")

    Path.wildcard(temp_pattern)
    |> Enum.each(&File.rm/1)
  end

  defp cleanup_template_cache do
    # Clean up any template caching
    :ok
  end
end
